/*
Copyright (c) 2015-2016 Timur Gafarov

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
*/

module dgl.templates.app3d;

import dlib.core.memory;
import dlib.container.array;
import dlib.container.dict;
import dlib.math.vector;
import dlib.math.matrix;
import dlib.math.affine;
import dlib.image.color;

import dgl.core.api;
import dgl.core.event;
import dgl.core.interfaces;
import dgl.graphics.pass;
import dgl.graphics.scene;
import dgl.graphics.entity;
import dgl.graphics.light;
import dgl.graphics.texture;
import dgl.graphics.material;
import dgl.graphics.shadow;
import dgl.asset.resource;
import dgl.asset.trimesh;
import dgl.asset.dgl3;
import dgl.asset.entity;

class LoadingScreen: EventListener, Drawable
{
    ResourceManager resourceManager;
    Texture loadingTexture;
    
    this(EventManager emngr, ResourceManager resman)
    {
        super(emngr);
        resourceManager = resman;
    }
    
    this(EventManager emngr, Texture loadingtex)
    {
        super(emngr);
        loadingTexture = loadingtex;
    }

    void update(double dt)
    {
    }

    void draw(double dt)
    {
        if (loadingTexture)
            loadingTexture.bind(dt);

        glColor4f(1, 1, 1, 1);
        glBegin(GL_QUADS);
        glTexCoord2f(0, 0); glVertex2f(0, eventManager.windowHeight);
        glTexCoord2f(0, 1); glVertex2f(0, 0);
        glTexCoord2f(1, 1); glVertex2f(eventManager.windowWidth, 0);
        glTexCoord2f(1, 0); glVertex2f(eventManager.windowWidth, eventManager.windowHeight);
        glEnd();
        glPopAttrib();

        if (loadingTexture)
            loadingTexture.unbind();
            
        glColor4f(1, 1, 1, 1);
        float margin = 2.0f;
        float w = resourceManager.loadingPercentage * eventManager.windowWidth;
        
        glBegin(GL_QUADS);
        glVertex2f(margin, 16);
        glVertex2f(margin, margin);
        glVertex2f(w - margin, margin);
        glVertex2f(w - margin, 16);
        glEnd();
        glPopAttrib();
    }
}

class Application3D: PassApplication
{
    ResourceManager resourceManager;
    Scene scene3d;
    Scene scene2d;
    Pass pass3d;
    Pass pass2d;
    LightManager lightManager;
    bool shadeless = false;
    LoadingScreen defaultLoadingScreen;
    LoadingScreen loadingScreen;

    this()
    {
        super();

        scene3d = New!Scene();
        scene2d = New!Scene();

        resourceManager = New!ResourceManager(scene3d.defaultMaterial);

        pass3d = addPass3D(scene3d);
        pass3d.clear = true;

        pass2d = addPass2D(scene2d);
        
        lightManager = New!LightManager();
        
        defaultLoadingScreen = New!LoadingScreen(eventManager, resourceManager);
        loadingScreen = defaultLoadingScreen;
        
        if (useShaders)
            scene3d.defaultMaterial.setShader();
    }
    
    static bool useShadows()
    {
        return ShadowMapPass.supported && 
               ShadowMapPass.isShadowsEnabled &&
               Material.isShadersEnabled;
    }

    static bool useShaders()
    {
        return Material.isShadersEnabled;
    }
    
    Light addPointLight(Vector3f pos)
    {
        return lightManager.addPointLight(pos);
    }

    void setCameraMatrix(Matrix4x4f m)
    {
        pass3d.modelViewMatrix = m;
    }

    /*
    void addEntitiesFromModel(string model)
    {
        foreach(name, e; getModel(model).entitiesByName)
        {
            addEntity3D(e);
        }
    }
    */
    /*
    void addLightsFromModel(string model)
    {
        foreach(name, e; getModel(model).entitiesByName)
        {
            if (e.type == 1)
            {
                Color4f col = e.props["color"].toColor4f;
                auto light = addPointLight(e.position);
                light.diffuseColor = col;
                light.highPriority = true;
                e.shadeless = true;
            }
        }
    }
    */

    Entity addEntity3D(string model, string name)
    {
        DGL3Resource r = getModel(model);
        Entity e = r.entitiesByName[name];
        scene3d.addEntity(e);
        return e;
    }

    Entity addEntity3D(Entity e)
    {
        scene3d.addEntity(e);
        return e;
    }

    Entity createEntity3D(Drawable d)
    {
        return scene3d.createEntity(d);
    }

    Entity addEntity2D(Entity e)
    {
        scene2d.addEntity(e);
        return e;
    }

    Entity createEntity2D(Drawable d)
    {
        return scene2d.createEntity(d);
    }

    size_t numEntities3D()
    {
        return scene3d.entities.length;
    }

    size_t numEntities2D()
    {
        return scene2d.entities.length;
    }

    void freeResources()
    {
        scene3d.free(); 
        scene2d.free();
        
        lightManager.freeLights();

        resourceManager.freeResources();
    }

    ~this()
    {
        Delete(resourceManager);

        Delete(scene3d);
        Delete(scene2d);

        Delete(lightManager);

        if (defaultLoadingScreen.loadingTexture !is null)
            Delete(defaultLoadingScreen.loadingTexture);
        Delete(defaultLoadingScreen);
    }

    override void onUpdate(double dt)
    {
        super.onUpdate(dt);
        scene3d.update(dt);
        scene2d.update(dt);
        
        if (!scene3d.shadeless)
            lightManager.calcLighting(scene3d);
    }

    void onLoadingUpdate(double dt)
    {
    }

    void onLoadingRedraw(double dt)
    {
        glPushAttrib(GL_ENABLE_BIT);
        glDisable(GL_LIGHTING);
        glDisable(GL_DEPTH_TEST);

        auto orthoProjection = orthoMatrix(
            0.0f, eventManager.windowWidth, 0.0f, eventManager.windowHeight, 0.0f, 1.0f);
        glMatrixMode(GL_PROJECTION);
        glLoadMatrixf(orthoProjection.arrayof.ptr);
        glMatrixMode(GL_MODELVIEW);
        glLoadIdentity();
        
        if (loadingScreen)
        {
            loadingScreen.update(dt);
            loadingScreen.draw(dt);
        }
    }

    TextureResource addTexureResource(string filename)
    {
        return resourceManager.addTextureResource(filename);
    }
   
    DGL3Resource addModelResource(string filename)
    {
        return resourceManager.addDGL3Resource(filename);
    }
    
    // TODO: existance check for resources

    bool textureExists(string name)
    {
        return resourceManager.textureExists(name);
    }

    Texture getTexture(string name)
    {
        return resourceManager.getTexture(name);
    }

    bool modelExists(string name)
    {
        return resourceManager.DGLResourceExists(name);
    }
    
    DGL3Resource getModel(string filename)
    {
        return (cast(DGL3Resource)resourceManager.resources[filename]);
    }

    bool meshExists(string model, string name)
    {
        if (modelExists(model))
            return (name in getModel(model).meshesByName) !is null;
        else
            return false;
    }
    
    Trimesh getMesh(string model, string name)
    {
        return (cast(DGL3Resource)resourceManager.resources[model]).meshesByName[name];
    }

    bool materialExists(string model, string name)
    {
        if (modelExists(model))
            return (name in getModel(model).materialsByName) !is null;
        else
            return false;
    }
    
    Material getMaterial(string model, string name)
    {
        return (cast(DGL3Resource)resourceManager.resources[model]).materialsByName[name];
    }

    bool entityExists(string model, string name)
    {
        if (modelExists(model))
            return (name in getModel(model).entitiesByName) !is null;
        else
            return false;
    }
    
    DGL3Entity getEntity(string model, string name)
    {
        return (cast(DGL3Resource)resourceManager.resources[model]).entitiesByName[name];
    }

    void setDefaultLoadingImage(string filename)
    {
        if (defaultLoadingScreen.loadingTexture !is null)
            Delete(defaultLoadingScreen.loadingTexture);

        defaultLoadingScreen.loadingTexture = resourceManager.loadTexture(filename);
    }

    void mountDirectory(string dir)
    {
        resourceManager.mountDirectory(dir);
    }

    void loadResources()
    {
        resourceManager.loadThreadSafePart();
        while(resourceManager.isLoading)
        {
            eventManager.update();
            processEvents();

            glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
            glViewport(0, 0, windowWidth, windowHeight);
            glScissor(0, 0, windowWidth, windowHeight);
            glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

            onLoadingUpdate(eventManager.deltaTime);
            onLoadingRedraw(eventManager.deltaTime);

            SDL_GL_SwapBuffers();
        }
        resourceManager.loadThreadUnsafePart();
    }
}

